from Pyblio.Callback import Publisher

class Undoable(Publisher):
    """ A simple stack of undoable actions. When actions are made by
    the user, they get added via doAction, which proceeds to run them
    immediately. The undo stacks also keeps track of a single save
    point, which is a point from which we know if the document is
    modified.

    If the 'undo' action is None, the 'do' action is expected to
    return a function that will perform the undo.
    """

    def __init__(self):
        Publisher.__init__(self)
        
        # Actions are triples:
        #  - 'do' function
        #  - 'undo' function
        #  - a boolean telling if 'undo' is generated by 'do', or is
        #  static
        
        self._actions = []
        self._undone  = []

        self._savepoint = 0
        return
    

    def doAction(self, action, reverse, done=False):
        # When an action is explicitely performed by the user, we
        # loose the capability to redo from that point on (assuming we
        # just did some undos). If we undid some actions after having
        # put a savePoint, and commit a new action, the savepoint
        # cannot be reached anymore: it needs to be deleted.
        if self._savepoint > len(self._actions):
            self._savepoint = None

        # We explicitely call the 'action' method, as this would be
        # invoked by the user anyway. In some cases, the user does not
        # want us to perform the operation, though.
        if done: r = None
        else:    r = action()

        if reverse is None:
            # The 'undo' method is dynamic, and needs to be updated
            # every time we run 'do'
            assert r is not None, "dynamic undo action requested, but the do action is not to be called"
            self._actions.append((action, r, True))
        else:
            # The 'undo' method is static
            self._actions.append((action, reverse, False))
        
        self._undone = []

        self.emit('can-undo', self.canUndo())
        self.emit('can-redo', self.canRedo())
        return

    def savePoint(self):
        """ The current state of the document has been saved."""
        self._savepoint = len(self._actions)
        return
    
    def isModified(self):
        return len(self._actions) != self._savepoint
    
    def canUndo(self):
        return len(self._actions) > 0

    def canRedo(self):
        return len(self._undone) > 0
    

    def undoAction(self):
        action = self._actions.pop()
        self._undone.append(action)

        action[1]()

        self.emit('can-undo', self.canUndo())
        self.emit('can-redo', self.canRedo())
        return

    def redoAction(self):
        do, undo, dynamic = self._undone.pop()

        r = do()
        
        if dynamic:
            self._actions.append((do, r, True))
        else:
            self._actions.append((do, undo, False))

        self.emit('can-undo', self.canUndo())
        self.emit('can-redo', self.canRedo())
        return
    
    
